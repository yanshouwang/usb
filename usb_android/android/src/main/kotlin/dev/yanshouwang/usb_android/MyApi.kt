// Autogenerated from Pigeon (v10.1.6), do not edit directly.
// See also: https://pub.dev/packages/pigeon

package dev.yanshouwang.usb_android

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  if (exception is FlutterError) {
    return listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    return listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface MyCollectorHostApi {
  fun free(hashCode: Long)

  companion object {
    /** The codec used by MyCollectorHostApi. */
    val codec: MessageCodec<Any?> by lazy {
      StandardMessageCodec()
    }
    /** Sets up an instance of `MyCollectorHostApi` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: MyCollectorHostApi?) {
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyCollectorHostApi.free", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              api.free(hashCodeArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * This class allows you to access the state of USB and communicate with USB devices. Currently only host mode is
 * supported in the public API.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface MyUsbManagerHostApi {
  /**
   * Returns a list of currently attached USB accessories. (in the current implementation there can be at most one)
   *
   * Requires the PackageManager#FEATURE_USB_ACCESSORY feature which can be detected using
   * PackageManager.hasSystemFeature(String).
   */
  fun getAccessories(): List<Long>
  /**
   * Returns a HashMap containing all USB devices currently attached. USB device name is the key for the returned
   * HashMap. The result will be empty if no devices are attached, or if USB host mode is inactive or unsupported.
   *
   * Requires the PackageManager#FEATURE_USB_HOST feature which can be detected using
   * PackageManager.hasSystemFeature(String).
   */
  fun getDevices(): Map<String, Long>
  /**
   * Returns true if the caller has permission to access the accessory. Permission might have been granted temporarily via
   * requestPermission(android.hardware.usb.UsbAccessory, android.app.PendingIntent) or by the user
   * choosing the caller as the default application for the accessory.
   *
   * Requires the PackageManager#FEATURE_USB_ACCESSORY feature which can be detected using
   * PackageManager.hasSystemFeature(String).
   */
  fun hasAccessoryPermission(hashCode: Long): Boolean
  fun requestAccessoryPermission(hashCode: Long)
  /**
   * Returns true if the caller has permission to access the device. Permission might have been granted temporarily via
   * requestPermission(android.hardware.usb.UsbDevice, android.app.PendingIntent) or by the user
   * choosing the caller as the default application for the device. Permission for USB devices of class
   * UsbConstants#USB_CLASS_VIDEO for clients that target SDK Build.VERSION_CODES.P and above can be granted
   * only if they have additionally the Manifest.permission.CAMERA permission.
   *
   * Requires the PackageManager#FEATURE_USB_HOST feature which can be detected using
   * PackageManager.hasSystemFeature(String).
   */
  fun hasDevicePermission(hashCode: Long): Boolean
  fun requestDevicePermission(hashCode: Long)

  companion object {
    /** The codec used by MyUsbManagerHostApi. */
    val codec: MessageCodec<Any?> by lazy {
      StandardMessageCodec()
    }
    /** Sets up an instance of `MyUsbManagerHostApi` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: MyUsbManagerHostApi?) {
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbManagerHostApi.getAccessories", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getAccessories())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbManagerHostApi.getDevices", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getDevices())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbManagerHostApi.hasAccessoryPermission", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.hasAccessoryPermission(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbManagerHostApi.requestAccessoryPermission", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              api.requestAccessoryPermission(hashCodeArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbManagerHostApi.hasDevicePermission", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.hasDevicePermission(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbManagerHostApi.requestDevicePermission", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              api.requestDevicePermission(hashCodeArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
@Suppress("UNCHECKED_CAST")
class MyUsbBroadcastReceiverFlutterApi(private val binaryMessenger: BinaryMessenger) {
  companion object {
    /** The codec used by MyUsbBroadcastReceiverFlutterApi. */
    val codec: MessageCodec<Any?> by lazy {
      StandardMessageCodec()
    }
  }
  fun onAccessoryAttached(hashCodeArg: Long, callback: () -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbBroadcastReceiverFlutterApi.onAccessoryAttached", codec)
    channel.send(listOf(hashCodeArg)) {
      callback()
    }
  }
  fun onAccessoryDetached(hashCodeArg: Long, callback: () -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbBroadcastReceiverFlutterApi.onAccessoryDetached", codec)
    channel.send(listOf(hashCodeArg)) {
      callback()
    }
  }
  fun onAccessoryPermissionReceived(hashCodeArg: Long, isGrantedArg: Boolean, callback: () -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbBroadcastReceiverFlutterApi.onAccessoryPermissionReceived", codec)
    channel.send(listOf(hashCodeArg, isGrantedArg)) {
      callback()
    }
  }
  fun onDeviceAttached(hashCodeArg: Long, callback: () -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbBroadcastReceiverFlutterApi.onDeviceAttached", codec)
    channel.send(listOf(hashCodeArg)) {
      callback()
    }
  }
  fun onDeviceDetached(hashCodeArg: Long, callback: () -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbBroadcastReceiverFlutterApi.onDeviceDetached", codec)
    channel.send(listOf(hashCodeArg)) {
      callback()
    }
  }
  fun onDevicePermissionReceived(hashCodeArg: Long, isGrantedArg: Boolean, callback: () -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbBroadcastReceiverFlutterApi.onDevicePermissionReceived", codec)
    channel.send(listOf(hashCodeArg, isGrantedArg)) {
      callback()
    }
  }
}
/**
 * A class representing a USB accessory, which is an external hardware component that communicates with an android
 * application over USB. The accessory is the USB host and android the device side of the USB connection.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface MyUsbAccessoryHostApi {
  fun getManufacturer(hashCode: Long): String
  fun getModel(hashCode: Long): String
  fun getDescription(hashCode: Long): String?
  fun getVersion(hashCode: Long): String?
  fun getUri(hashCode: Long): String?
  fun getSerial(hashCode: Long): String?

  companion object {
    /** The codec used by MyUsbAccessoryHostApi. */
    val codec: MessageCodec<Any?> by lazy {
      StandardMessageCodec()
    }
    /** Sets up an instance of `MyUsbAccessoryHostApi` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: MyUsbAccessoryHostApi?) {
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbAccessoryHostApi.getManufacturer", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getManufacturer(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbAccessoryHostApi.getModel", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getModel(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbAccessoryHostApi.getDescription", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getDescription(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbAccessoryHostApi.getVersion", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getVersion(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbAccessoryHostApi.getUri", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getUri(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbAccessoryHostApi.getSerial", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getSerial(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * This class represents a USB device attached to the android device with the android device acting as the USB host. Each
 * device contains one or more UsbInterfaces, each of which contains a number of UsbEndpoints (the channels via
 * which data is transmitted over USB).
 *
 * This class contains information (along with UsbInterface and UsbEndpoint) that describes the capabilities of the
 * USB device. To communicate with the device, you open a UsbDeviceConnection for the device and use UsbRequest
 * to send and receive data on an endpoint. UsbDeviceConnection#controlTransfer is used for control requests on
 * endpoint zero.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface MyUsbDeviceHostApi {
  fun getDeviceClass(hashCode: Long): Long
  fun getDeviceSubClass(hashCode: Long): Long
  fun getDeviceProtocol(hashCode: Long): Long
  fun getDeviceName(hashCode: Long): String
  fun getVendorId(hashCode: Long): Long
  fun getProductId(hashCode: Long): Long
  fun getManufacturerName(hashCode: Long): String?
  fun getProductName(hashCode: Long): String?
  fun getConfigurationCount(hashCode: Long): Long
  fun getInterfaceCount(hashCode: Long): Long
  fun getVersion(hashCode: Long): String
  fun getSerialNumber(hashCode: Long): String?
  /** Returns the UsbConfiguration at the given index. */
  fun getConfiguration(hashCode: Long, index: Long): Long
  /**
   * Returns the UsbInterface at the given index. For devices with multiple configurations, you will probably want to use
   * UsbConfiguration#getInterface instead.
   */
  fun getInterface(hashCode: Long, index: Long): Long

  companion object {
    /** The codec used by MyUsbDeviceHostApi. */
    val codec: MessageCodec<Any?> by lazy {
      StandardMessageCodec()
    }
    /** Sets up an instance of `MyUsbDeviceHostApi` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: MyUsbDeviceHostApi?) {
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbDeviceHostApi.getDeviceClass", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getDeviceClass(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbDeviceHostApi.getDeviceSubClass", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getDeviceSubClass(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbDeviceHostApi.getDeviceProtocol", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getDeviceProtocol(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbDeviceHostApi.getDeviceName", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getDeviceName(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbDeviceHostApi.getVendorId", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getVendorId(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbDeviceHostApi.getProductId", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getProductId(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbDeviceHostApi.getManufacturerName", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getManufacturerName(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbDeviceHostApi.getProductName", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getProductName(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbDeviceHostApi.getConfigurationCount", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getConfigurationCount(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbDeviceHostApi.getInterfaceCount", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getInterfaceCount(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbDeviceHostApi.getVersion", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getVersion(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbDeviceHostApi.getSerialNumber", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getSerialNumber(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbDeviceHostApi.getConfiguration", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val indexArg = args[1].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getConfiguration(hashCodeArg, indexArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbDeviceHostApi.getInterface", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val indexArg = args[1].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getInterface(hashCodeArg, indexArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * A class representing a configuration on a UsbDevice. A USB configuration can have one or more interfaces, each one
 * providing a different piece of functionality, separate from the other interfaces. An interface will have one or more
 * UsbEndpoints, which are the channels by which the host transfers data with the device.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface MyUsbConfigurationHostApi {
  fun getId(hashCode: Long): Long
  fun getName(hashCode: Long): String?
  fun getMaxPower(hashCode: Long): Long
  fun getInterfaceCount(hashCode: Long): Long
  fun getIsRemoteWakeup(hashCode: Long): Boolean
  fun getIsSelfPowered(hashCode: Long): Boolean
  /** Returns the UsbInterface at the given index. */
  fun getInterface(hashCode: Long, index: Long): Long

  companion object {
    /** The codec used by MyUsbConfigurationHostApi. */
    val codec: MessageCodec<Any?> by lazy {
      StandardMessageCodec()
    }
    /** Sets up an instance of `MyUsbConfigurationHostApi` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: MyUsbConfigurationHostApi?) {
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbConfigurationHostApi.getId", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getId(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbConfigurationHostApi.getName", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getName(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbConfigurationHostApi.getMaxPower", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getMaxPower(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbConfigurationHostApi.getInterfaceCount", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getInterfaceCount(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbConfigurationHostApi.getIsRemoteWakeup", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getIsRemoteWakeup(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbConfigurationHostApi.getIsSelfPowered", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getIsSelfPowered(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbConfigurationHostApi.getInterface", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val indexArg = args[1].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getInterface(hashCodeArg, indexArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface MyUsbInterfaceHostApi {
  fun getId(hashCode: Long): Long
  fun getAlternateSetting(hashCode: Long): Long
  fun getInterfaceClass(hashCode: Long): Long
  fun getInterfaceSubclass(hashCode: Long): Long
  fun getInterfaceProtocol(hashCode: Long): Long
  fun getName(hashCode: Long): String?
  fun getEndpointCount(hashCode: Long): Long

  companion object {
    /** The codec used by MyUsbInterfaceHostApi. */
    val codec: MessageCodec<Any?> by lazy {
      StandardMessageCodec()
    }
    /** Sets up an instance of `MyUsbInterfaceHostApi` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: MyUsbInterfaceHostApi?) {
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbInterfaceHostApi.getId", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getId(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbInterfaceHostApi.getAlternateSetting", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getAlternateSetting(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbInterfaceHostApi.getInterfaceClass", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getInterfaceClass(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbInterfaceHostApi.getInterfaceSubclass", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getInterfaceSubclass(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbInterfaceHostApi.getInterfaceProtocol", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getInterfaceProtocol(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbInterfaceHostApi.getName", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getName(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.MyUsbInterfaceHostApi.getEndpointCount", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getEndpointCount(hashCodeArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
