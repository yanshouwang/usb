// Autogenerated from Pigeon (v20.0.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")

package dev.yanshouwang.usb_android

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  return if (exception is FlutterError) {
    listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

private fun createConnectionError(channelName: String): FlutterError {
  return FlutterError("channel-error",  "Unable to establish connection on channel: '$channelName'.", "")}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()
private object USBPigeonPigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return     super.readValueOfType(type, buffer)
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    super.writeValue(stream, value)
  }
}

/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface FinalizerHostAPI {
  fun free(hashCode: Long)

  companion object {
    /** The codec used by FinalizerHostAPI. */
    val codec: MessageCodec<Any?> by lazy {
      USBPigeonPigeonCodec
    }
    /** Sets up an instance of `FinalizerHostAPI` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: FinalizerHostAPI?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.FinalizerHostAPI.free$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              api.free(hashCodeArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * This class allows you to access the state of USB and communicate with USB devices. Currently only host mode is
 * supported in the public API.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface USBManagerHostAPI {
  /**
   * Returns a list of currently attached USB accessories. (in the current implementation there can be at most one)
   *
   * Requires the PackageManager#FEATURE_USB_ACCESSORY feature which can be detected using
   * PackageManager.hasSystemFeature(String).
   */
  fun getAccessories(): List<Long>
  /**
   * Returns true if the caller has permission to access the accessory. Permission might have been granted temporarily via
   * requestPermission(android.hardware.usb.UsbAccessory, android.app.PendingIntent) or by the user
   * choosing the caller as the default application for the accessory.
   *
   * Requires the PackageManager#FEATURE_USB_ACCESSORY feature which can be detected using
   * PackageManager.hasSystemFeature(String).
   */
  fun hasAccessoryPermission(hashCode: Long): Boolean
  fun requestAccessoryPermission(hashCode: Long)
  /**
   * Returns a HashMap containing all USB devices currently attached. USB device name is the key for the returned
   * HashMap. The result will be empty if no devices are attached, or if USB host mode is inactive or unsupported.
   *
   * Requires the PackageManager#FEATURE_USB_HOST feature which can be detected using
   * PackageManager.hasSystemFeature(String).
   */
  fun getDevices(): Map<String, Long>
  /**
   * Returns true if the caller has permission to access the device. Permission might have been granted temporarily via
   * requestPermission(android.hardware.usb.UsbDevice, android.app.PendingIntent) or by the user
   * choosing the caller as the default application for the device. Permission for USB devices of class
   * UsbConstants#USB_CLASS_VIDEO for clients that target SDK Build.VERSION_CODES.P and above can be granted
   * only if they have additionally the Manifest.permission.CAMERA permission.
   *
   * Requires the PackageManager#FEATURE_USB_HOST feature which can be detected using
   * PackageManager.hasSystemFeature(String).
   */
  fun hasDevicePermission(hashCode: Long): Boolean
  fun requestDevicePermission(hashCode: Long)
  fun openDevice(hashCode: Long): Long

  companion object {
    /** The codec used by USBManagerHostAPI. */
    val codec: MessageCodec<Any?> by lazy {
      USBPigeonPigeonCodec
    }
    /** Sets up an instance of `USBManagerHostAPI` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: USBManagerHostAPI?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBManagerHostAPI.getAccessories$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getAccessories())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBManagerHostAPI.hasAccessoryPermission$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.hasAccessoryPermission(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBManagerHostAPI.requestAccessoryPermission$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              api.requestAccessoryPermission(hashCodeArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBManagerHostAPI.getDevices$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getDevices())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBManagerHostAPI.hasDevicePermission$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.hasDevicePermission(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBManagerHostAPI.requestDevicePermission$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              api.requestDevicePermission(hashCodeArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBManagerHostAPI.openDevice$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.openDevice(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * A class representing a USB accessory, which is an external hardware component that communicates with an android
 * application over USB. The accessory is the USB host and android the device side of the USB connection.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface USBAccessoryHostAPI {
  fun getManufacturer(hashCode: Long): String
  fun getModel(hashCode: Long): String
  fun getDescription(hashCode: Long): String?
  fun getVersion(hashCode: Long): String?
  fun getUri(hashCode: Long): String?
  fun getSerial(hashCode: Long): String?

  companion object {
    /** The codec used by USBAccessoryHostAPI. */
    val codec: MessageCodec<Any?> by lazy {
      USBPigeonPigeonCodec
    }
    /** Sets up an instance of `USBAccessoryHostAPI` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: USBAccessoryHostAPI?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBAccessoryHostAPI.getManufacturer$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getManufacturer(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBAccessoryHostAPI.getModel$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getModel(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBAccessoryHostAPI.getDescription$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getDescription(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBAccessoryHostAPI.getVersion$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getVersion(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBAccessoryHostAPI.getUri$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getUri(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBAccessoryHostAPI.getSerial$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getSerial(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * This class represents a USB device attached to the android device with the android device acting as the USB host. Each
 * device contains one or more UsbInterfaces, each of which contains a number of UsbEndpoints (the channels via
 * which data is transmitted over USB).
 *
 * This class contains information (along with UsbInterface and UsbEndpoint) that describes the capabilities of the
 * USB device. To communicate with the device, you open a UsbDeviceConnection for the device and use UsbRequest
 * to send and receive data on an endpoint. UsbDeviceConnection#controlTransfer is used for control requests on
 * endpoint zero.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface USBDeviceHostAPI {
  fun getDeviceClass(hashCode: Long): Long
  fun getDeviceSubClass(hashCode: Long): Long
  fun getDeviceProtocol(hashCode: Long): Long
  fun getDeviceName(hashCode: Long): String
  fun getVendorId(hashCode: Long): Long
  fun getProductId(hashCode: Long): Long
  fun getManufacturerName(hashCode: Long): String?
  fun getProductName(hashCode: Long): String?
  fun getConfigurationCount(hashCode: Long): Long
  fun getInterfaceCount(hashCode: Long): Long
  fun getVersion(hashCode: Long): String
  fun getSerialNumber(hashCode: Long): String?
  /** Returns the UsbConfiguration at the given index. */
  fun getConfiguration(hashCode: Long, index: Long): Long
  /**
   * Returns the UsbInterface at the given index. For devices with multiple configurations, you will probably want to use
   * UsbConfiguration#getInterface instead.
   */
  fun getInterface(hashCode: Long, index: Long): Long

  companion object {
    /** The codec used by USBDeviceHostAPI. */
    val codec: MessageCodec<Any?> by lazy {
      USBPigeonPigeonCodec
    }
    /** Sets up an instance of `USBDeviceHostAPI` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: USBDeviceHostAPI?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBDeviceHostAPI.getDeviceClass$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getDeviceClass(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBDeviceHostAPI.getDeviceSubClass$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getDeviceSubClass(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBDeviceHostAPI.getDeviceProtocol$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getDeviceProtocol(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBDeviceHostAPI.getDeviceName$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getDeviceName(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBDeviceHostAPI.getVendorId$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getVendorId(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBDeviceHostAPI.getProductId$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getProductId(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBDeviceHostAPI.getManufacturerName$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getManufacturerName(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBDeviceHostAPI.getProductName$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getProductName(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBDeviceHostAPI.getConfigurationCount$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getConfigurationCount(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBDeviceHostAPI.getInterfaceCount$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getInterfaceCount(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBDeviceHostAPI.getVersion$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getVersion(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBDeviceHostAPI.getSerialNumber$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getSerialNumber(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBDeviceHostAPI.getConfiguration$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val indexArg = args[1].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getConfiguration(hashCodeArg, indexArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBDeviceHostAPI.getInterface$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val indexArg = args[1].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getInterface(hashCodeArg, indexArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * A class representing a configuration on a UsbDevice. A USB configuration can have one or more interfaces, each one
 * providing a different piece of functionality, separate from the other interfaces. An interface will have one or more
 * UsbEndpoints, which are the channels by which the host transfers data with the device.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface USBConfigurationHostAPI {
  fun getId(hashCode: Long): Long
  fun getName(hashCode: Long): String?
  fun getMaxPower(hashCode: Long): Long
  fun getInterfaceCount(hashCode: Long): Long
  fun getIsRemoteWakeup(hashCode: Long): Boolean
  fun getIsSelfPowered(hashCode: Long): Boolean
  /** Returns the UsbInterface at the given index. */
  fun getInterface(hashCode: Long, index: Long): Long

  companion object {
    /** The codec used by USBConfigurationHostAPI. */
    val codec: MessageCodec<Any?> by lazy {
      USBPigeonPigeonCodec
    }
    /** Sets up an instance of `USBConfigurationHostAPI` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: USBConfigurationHostAPI?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBConfigurationHostAPI.getId$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getId(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBConfigurationHostAPI.getName$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getName(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBConfigurationHostAPI.getMaxPower$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getMaxPower(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBConfigurationHostAPI.getInterfaceCount$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getInterfaceCount(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBConfigurationHostAPI.getIsRemoteWakeup$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getIsRemoteWakeup(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBConfigurationHostAPI.getIsSelfPowered$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getIsSelfPowered(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBConfigurationHostAPI.getInterface$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val indexArg = args[1].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getInterface(hashCodeArg, indexArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface USBInterfaceHostAPI {
  fun getId(hashCode: Long): Long
  fun getAlternateSetting(hashCode: Long): Long
  fun getInterfaceClass(hashCode: Long): Long
  fun getInterfaceSubclass(hashCode: Long): Long
  fun getInterfaceProtocol(hashCode: Long): Long
  fun getName(hashCode: Long): String?
  fun getEndpointCount(hashCode: Long): Long

  companion object {
    /** The codec used by USBInterfaceHostAPI. */
    val codec: MessageCodec<Any?> by lazy {
      USBPigeonPigeonCodec
    }
    /** Sets up an instance of `USBInterfaceHostAPI` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: USBInterfaceHostAPI?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBInterfaceHostAPI.getId$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getId(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBInterfaceHostAPI.getAlternateSetting$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getAlternateSetting(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBInterfaceHostAPI.getInterfaceClass$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getInterfaceClass(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBInterfaceHostAPI.getInterfaceSubclass$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getInterfaceSubclass(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBInterfaceHostAPI.getInterfaceProtocol$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getInterfaceProtocol(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBInterfaceHostAPI.getName$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getName(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBInterfaceHostAPI.getEndpointCount$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getEndpointCount(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface USBDeviceConnectionHostAPI {
  fun getFileDescriptor(hashCode: Long): Long
  fun close(hashCode: Long)

  companion object {
    /** The codec used by USBDeviceConnectionHostAPI. */
    val codec: MessageCodec<Any?> by lazy {
      USBPigeonPigeonCodec
    }
    /** Sets up an instance of `USBDeviceConnectionHostAPI` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: USBDeviceConnectionHostAPI?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBDeviceConnectionHostAPI.getFileDescriptor$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              listOf(api.getFileDescriptor(hashCodeArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.usb_android.USBDeviceConnectionHostAPI.close$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hashCodeArg = args[0].let { num -> if (num is Int) num.toLong() else num as Long }
            val wrapped: List<Any?> = try {
              api.close(hashCodeArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class USBBroadcastReceiverFlutterAPI(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by USBBroadcastReceiverFlutterAPI. */
    val codec: MessageCodec<Any?> by lazy {
      USBPigeonPigeonCodec
    }
  }
  fun onAccessoryAttached(hashCodeArg: Long, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.usb_android.USBBroadcastReceiverFlutterAPI.onAccessoryAttached$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(hashCodeArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onAccessoryDetached(hashCodeArg: Long, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.usb_android.USBBroadcastReceiverFlutterAPI.onAccessoryDetached$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(hashCodeArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onAccessoryPermission(hashCodeArg: Long, isGrantedArg: Boolean, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.usb_android.USBBroadcastReceiverFlutterAPI.onAccessoryPermission$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(hashCodeArg, isGrantedArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onDeviceDetached(hashCodeArg: Long, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.usb_android.USBBroadcastReceiverFlutterAPI.onDeviceDetached$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(hashCodeArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onDeviceAttached(hashCodeArg: Long, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.usb_android.USBBroadcastReceiverFlutterAPI.onDeviceAttached$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(hashCodeArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  fun onDevicePermission(hashCodeArg: Long, isGrantedArg: Boolean, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.usb_android.USBBroadcastReceiverFlutterAPI.onDevicePermission$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(hashCodeArg, isGrantedArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
}
